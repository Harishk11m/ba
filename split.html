<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XLSX to CSV Converter</title>
        <script src="https://cdn.tailwindcss.com"></script>
        <style>
        body {
            font-family: 'Inter', sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen flex items-center justify-center p-4">

        <div class="bg-white p-8 rounded-2xl shadow-xl max-w-xl w-full text-center">

                <h1 class="text-3xl font-bold text-gray-800 mb-2">XLSX to CSV Converter</h1>
        <p class="text-gray-600 mb-6">Select one or more Excel (.xlsx) files to convert them to Comma-Separated Values (.csv) files, split by the exact timestamp.</p>

                <input type="file" id="fileInput" accept=".xlsx" class="hidden" multiple />
        
                <button onclick="document.getElementById('fileInput').click()"
            class="w-full bg-blue-600 hover:bg-blue-700 text-white font-semibold py-3 px-6 rounded-xl transition duration-300 ease-in-out shadow-lg transform hover:scale-105 mb-6">
            Choose Excel Files
        </button>

                <div id="columnInputContainer" class="hidden mb-4">
            <label for="timeColumnName" class="block text-gray-700 font-medium mb-2 text-left">Enter the name of the timestamp column:</label>
            <input type="text" id="timeColumnName" placeholder="IST TIME" value="IST TIME"
                   class="w-full px-4 py-2 border border-gray-300 rounded-xl focus:outline-none focus:ring-2 focus:ring-blue-500" />
            <button id="splitButton"
                    class="mt-4 w-full bg-blue-600 hover:bg-blue-700 text-white font-semibold py-3 px-6 rounded-xl transition duration-300 ease-in-out">
                Split and Convert All
            </button>
        </div>

                <div id="statusMessage" class="text-gray-700 font-medium mb-4"></div>

                <div id="downloadContainer" class="hidden">
            <h2 class="text-xl font-bold text-gray-800 mb-4">Download your files:</h2>
            <div id="downloadLinks" class="space-y-3">
                            </div>
            <button id="downloadAllButton"
                    class="mt-6 w-full bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-3 px-6 rounded-xl transition duration-300 ease-in-out shadow-lg transform hover:scale-105">
                Download All as ZIP
            </button>
        </div>
    </div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.7.1/jszip.min.js"></script>

<script>
    // Get references to DOM elements
    const fileInput = document.getElementById('fileInput');
    const statusMessage = document.getElementById('statusMessage');
    const columnInputContainer = document.getElementById('columnInputContainer');
    const timeColumnNameInput = document.getElementById('timeColumnName');
    const splitButton = document.getElementById('splitButton');
    const downloadContainer = document.getElementById('downloadContainer');
    const downloadLinks = document.getElementById('downloadLinks'); // Kept for reference but not used for links
    const downloadAllButton = document.getElementById('downloadAllButton');

    let uploadedFiles = null;
    let allCSVs = []; // Array to hold all CSV data and filenames

    // --- Helper Function to Trigger Download ---
    function triggerDownload(url, filename) {
        const link = document.createElement('a');
        link.href = url;
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    }
    
    // Listen for a file to be selected
    fileInput.addEventListener('change', handleFiles, false);
    
    // Listen for the split button to be clicked - Modified to handle multiple files sequentially
    splitButton.addEventListener('click', async () => {
        if (!uploadedFiles || uploadedFiles.length === 0) {
            statusMessage.textContent = 'Please select files first.';
            return;
        }
        
        allCSVs = []; // Reset the list of CSVs for a new batch of files
        statusMessage.textContent = `Starting conversion for ${uploadedFiles.length} file(s)...`;
        downloadContainer.classList.add('hidden');
        downloadLinks.innerHTML = '';

        const filesArray = Array.from(uploadedFiles);
        
        try {
            // Process each file sequentially and wait for it to complete
            for (const file of filesArray) {
                await processFile(file);
                statusMessage.textContent = `Finished processing "${file.name}". Starting next file...`;
            }

            // After all files are processed, show the download button (which now only zips)
            if (allCSVs.length > 0) {
                downloadContainer.classList.remove('hidden');
                statusMessage.textContent = `All files processed! ${allCSVs.length} CSV files generated.`;
            } else {
                statusMessage.textContent = `Finished processing all files, but no CSVs were generated.`;
            }

        } catch (error) {
            console.error("Overall processing error:", error);
            statusMessage.textContent = `A critical error occurred during batch processing. Check console for details.`;
        }
    });

    // Listen for the Download All button to be clicked
    downloadAllButton.addEventListener('click', downloadAllAsZip, false);

    /**
     * Handles the file selection event and stores the files for later processing.
     * @param {Event} event The file input change event.
     */
    function handleFiles(event) {
        uploadedFiles = event.target.files;

        if (!uploadedFiles || uploadedFiles.length === 0) {
            statusMessage.textContent = 'No files selected.';
            columnInputContainer.classList.add('hidden');
            return;
        }

        statusMessage.textContent = `${uploadedFiles.length} file(s) selected. Please enter the column name to split by.`;
        columnInputContainer.classList.remove('hidden');
        downloadContainer.classList.add('hidden');
        downloadLinks.innerHTML = '';
    }

    /**
     * Processes an individual file, splits it by time, and *triggers immediate download* for each CSV.
     * It returns a Promise that resolves when the file processing is complete.
     * @param {File} file The file object to process.
     * @returns {Promise<void>}
     */
    function processFile(file) {
        return new Promise((resolve, reject) => {
            const timeColumnName = timeColumnNameInput.value.trim();
            if (!timeColumnName) {
                statusMessage.textContent = 'Please enter a column name.';
                return reject(new Error('Missing column name.'));
            }

            statusMessage.textContent = `Processing "${file.name}"...`;

            const reader = new FileReader();

            reader.onload = function(e) {
                try {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, { type: 'array' });
                    const sheetName = workbook.SheetNames[0];
                    const worksheet = workbook.Sheets[sheetName];
                    
                    // Get the value of cell D2 and create a prefix for the filename
                    const d2Cell = worksheet['D2'];
                    const filePrefix = (d2Cell && d2Cell.v ? String(d2Cell.v).substring(0, 3) : 'DEF').toUpperCase();

                    // Convert the sheet to an array of JSON objects
                    const jsonData = XLSX.utils.sheet_to_json(worksheet);

                    if (jsonData.length === 0) {
                        statusMessage.textContent = `Error: The sheet in "${file.name}" is empty.`;
                        return resolve(); // Resolve to continue to the next file
                    }

                    // Find the F column header, robustly
                    // Assuming 'F' column header means the header that was in column F in the XLSX
                    const fKey = Object.keys(jsonData[0] || {}).find(key => String(key).trim().toUpperCase() === 'F');

                    // Group rows by the specified time column's exact value
                    const groupedData = {};
                    jsonData.forEach(row => {
                        const timeValue = row[timeColumnName];
                        // Use a consistent key for grouping
                        const key = timeValue ? String(timeValue).trim() : 'undated-records';
                        
                        if (!groupedData[key]) {
                            groupedData[key] = [];
                        }
                        groupedData[key].push(row);
                    });

                    const uniqueTimeKeys = Object.keys(groupedData);
                    if (uniqueTimeKeys.length === 0) {
                        statusMessage.textContent = `No data found in "${file.name}" to split based on the column "${timeColumnName}".`;
                        return resolve(); // Resolve to continue to the next file
                    }

                    let filesGeneratedCount = 0;

                    uniqueTimeKeys.forEach(timeKey => {
                        const group = groupedData[timeKey];
                        const groupWorksheet = XLSX.utils.json_to_sheet(group);
                        const csvData = XLSX.utils.sheet_to_csv(groupWorksheet);

                        const blob = new Blob([csvData], { type: 'text/csv;charset=utf-8;' });
                        const url = URL.createObjectURL(blob);
                        
                        const originalFileNameWithoutExtension = file.name.split('.').slice(0, -1).join('.');
                        
                        // Use the value from the specified F column, or a fallback
                        const fColumnValue = fKey && group[0][fKey] ? String(group[0][fKey]).trim() : '';
                        const safeFColumnValue = fColumnValue.replace(/[\\/:*?"<>|]/g, '');
                        const rowCount = group.length;

                        // Create the final file name
                        const timePart = timeKey === 'undated-records' ? 'UNDATED' : timeKey.replace(/[\\/:*?"<>|]/g, '_');
                        const fileName = `${originalFileNameWithoutExtension}_${timePart}_${safeFColumnValue}_${rowCount}_ROWS.csv`.trim();
                        
                        // 1. Add to the global array for ZIP download
                        allCSVs.push({ filename: fileName, data: csvData });
                        
                        // 2. Trigger immediate download for the individual file
                        triggerDownload(url, fileName);
                        filesGeneratedCount++;
                    });

                    statusMessage.textContent = `Successfully generated ${filesGeneratedCount} CSV file(s) from "${file.name}".`;
                    resolve();

                } catch (error) {
                    console.error(`An error occurred during conversion for ${file.name}:`, error);
                    statusMessage.textContent = `Error: An unexpected error occurred while processing "${file.name}". Please ensure the file is a valid .xlsx file and the column name is correct.`;
                    reject(error); // Reject the promise
                }
            };

            reader.onerror = function() {
                statusMessage.textContent = `Error reading file: "${file.name}".`;
                reject(new Error(`Error reading file: ${file.name}`));
            };

            reader.readAsArrayBuffer(file);
        });
    }

    /**
     * Downloads all generated CSVs as a single ZIP file.
     */
    function downloadAllAsZip() {
        if (allCSVs.length === 0) {
            alert("No files to download. Please convert files first.");
            return;
        }
        
        statusMessage.textContent = `Creating ZIP archive with ${allCSVs.length} files...`;

        const zip = new JSZip();
        allCSVs.forEach(file => {
            // Add file to ZIP, using a new name format to ensure uniqueness in the ZIP
            const uniqueFilename = `${Date.now()}_${Math.random().toString(36).substring(2, 8)}_${file.filename}`;
            zip.file(file.filename, file.data);
        });

        zip.generateAsync({ type: "blob" })
            .then(function (content) {
                const zipFileName = "xlsx_to_csv_export.zip";
                triggerDownload(URL.createObjectURL(content), zipFileName);
                statusMessage.textContent = `ZIP file "${zipFileName}" created and download started!`;
            })
            .catch(error => {
                console.error("Error generating ZIP:", error);
                statusMessage.textContent = "Error creating ZIP file. Check console for details.";
            });
    }
</script>

</body>
</html>