<!DOCTYPE html>
<html lang="en">
<head>
Â  Â  <meta charset="UTF-8">
Â  Â  <meta name="viewport" content="width=device-width, initial-scale=1.0">
Â  Â  <title>XLSX to CSV Converter</title>
Â  Â  <script src="https://cdn.tailwindcss.com"></script>
Â  Â  <style>
Â  Â  Â  Â  body {
Â  Â  Â  Â  Â  Â  font-family: 'Inter', sans-serif;
Â  Â  Â  Â  Â  Â  -webkit-font-smoothing: antialiased;
Â  Â  Â  Â  Â  Â  -moz-osx-font-smoothing: grayscale;
Â  Â  Â  Â  }
Â  Â  </style>
</head>
<body class="bg-gray-100 min-h-screen flex items-center justify-center p-4">

Â  Â  <div class="bg-white p-8 rounded-2xl shadow-xl max-w-xl w-full text-center">

Â  Â  Â  Â  <h1 class="text-3xl font-bold text-gray-800 mb-2">XLSX to CSV Converter</h1>
Â  Â  Â  Â  <p class="text-gray-600 mb-6">Select one or more Excel (.xlsx) files to convert them to Comma-Separated Values (.csv) files, split by the exact timestamp.</p>

Â  Â  Â  Â  <input type="file" id="fileInput" accept=".xlsx" class="hidden" multiple />
Â  Â  Â  Â Â 
Â  Â  Â  Â  <button onclick="document.getElementById('fileInput').click()"
Â  Â  Â  Â  Â  Â  class="w-full bg-blue-600 hover:bg-blue-700 text-white font-semibold py-3 px-6 rounded-xl transition duration-300 ease-in-out shadow-lg transform hover:scale-105 mb-6">
Â  Â  Â  Â  Â  Â  Choose Excel Files
Â  Â  Â  Â  </button>

Â  Â  Â  Â  <div id="columnInputContainer" class="hidden mb-4">
Â  Â  Â  Â  Â  Â  <label for="timeColumnName" class="block text-gray-700 font-medium mb-2 text-left">Enter the name of the timestamp column:</label>
Â  Â  Â  Â  Â  Â  <input type="text" id="timeColumnName" placeholder="IST TIME" value="IST TIME"
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â class="w-full px-4 py-2 border border-gray-300 rounded-xl focus:outline-none focus:ring-2 focus:ring-blue-500" />
Â  Â  Â  Â  Â  Â  <button id="splitButton"
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  class="mt-4 w-full bg-blue-600 hover:bg-blue-700 text-white font-semibold py-3 px-6 rounded-xl transition duration-300 ease-in-out">
Â  Â  Â  Â  Â  Â  Â  Â  Split and Convert All
Â  Â  Â  Â  Â  Â  </button>
Â  Â  Â  Â  </div>

Â  Â  Â  Â  <div id="statusMessage" class="text-gray-700 font-medium mb-4"></div>

Â  Â  Â  Â  <div id="downloadContainer" class="hidden">
Â  Â  Â  Â  Â  Â  <h2 class="text-xl font-bold text-gray-800 mb-4">Download your files:</h2>
Â  Â  Â  Â  Â  Â  <div id="downloadLinks" class="space-y-3">
Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  <button id="downloadAllButton"
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  class="mt-6 w-full bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-3 px-6 rounded-xl transition duration-300 ease-in-out shadow-lg transform hover:scale-105">
Â  Â  Â  Â  Â  Â  Â  Â  Download All as ZIP
Â  Â  Â  Â  Â  Â  </button>
Â  Â  Â  Â  </div>
Â  Â  </div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.7.1/jszip.min.js"></script>

<script>
Â  Â  // Get references to DOM elements
Â  Â  const fileInput = document.getElementById('fileInput');
Â  Â  const statusMessage = document.getElementById('statusMessage');
Â  Â  const columnInputContainer = document.getElementById('columnInputContainer');
Â  Â  const timeColumnNameInput = document.getElementById('timeColumnName');
Â  Â  const splitButton = document.getElementById('splitButton');
Â  Â  const downloadContainer = document.getElementById('downloadContainer');
Â  Â  const downloadLinks = document.getElementById('downloadLinks');Â 
Â  Â  const downloadAllButton = document.getElementById('downloadAllButton');

Â  Â  let uploadedFiles = null;
Â  Â  let allCSVs = []; // Array to hold all CSV data and filenames

Â  Â  // --- Helper Function to Trigger Download ---
Â  Â  function triggerDownload(url, filename) {
Â  Â  Â  Â  const link = document.createElement('a');
Â  Â  Â  Â  link.href = url;
Â  Â  Â  Â  link.download = filename;
Â  Â  Â  Â  document.body.appendChild(link);
Â  Â  Â  Â  link.click();
Â  Â  Â  Â  document.body.removeChild(link);
Â  Â  }
Â  Â Â 
Â  Â  // Listen for a file to be selected
Â  Â  fileInput.addEventListener('change', handleFiles, false);
Â  Â Â 
Â  Â  // Listen for the split button to be clicked - Now triggers the entire batch process and final ZIP download
Â  Â  splitButton.addEventListener('click', async () => {
Â  Â  Â  Â  if (!uploadedFiles || uploadedFiles.length === 0) {
Â  Â  Â  Â  Â  Â  statusMessage.textContent = 'Please select files first.';
Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  }
Â  Â  Â  Â Â 
Â  Â  Â  Â  allCSVs = []; // Reset the list of CSVs for a new batch of files
Â  Â  Â  Â  statusMessage.textContent = `Starting conversion for ${uploadedFiles.length} file(s)... This may take a moment... â³`;
Â  Â  Â  Â  downloadContainer.classList.add('hidden');
Â  Â  Â  Â  downloadLinks.innerHTML = ''; // Clear previous links

Â  Â  Â  Â  const filesArray = Array.from(uploadedFiles);
Â  Â  Â  Â  let errorCount = 0;
Â  Â  Â  Â Â 
Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  Â  // Process each file sequentially and wait for it to complete
Â  Â  Â  Â  Â  Â  for (const file of filesArray) {
Â  Â  Â  Â  Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  await processFile(file);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  statusMessage.textContent = `Finished processing "${file.name}". Starting next file...`;
Â  Â  Â  Â  Â  Â  Â  Â  } catch (e) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  console.error(`Error processing file ${file.name}:`, e);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  statusMessage.textContent = `Error processing "${file.name}". Skipping file.`;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  errorCount++;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  // After all files are processed, generate and download the ZIP
Â  Â  Â  Â  Â  Â  if (allCSVs.length > 0) {
Â  Â  Â  Â  Â  Â  Â  Â  statusMessage.innerHTML = `All files processed! The following ${allCSVs.length} files will be in the ZIP: <ul class="list-disc list-inside mt-2 text-left">` + allCSVs.map(f => `<li class="text-sm text-gray-600">${f.filename}</li>`).join('') + `</ul>`;
Â  Â  Â  Â  Â  Â  Â  Â  await downloadAllAsZip(); // Call the ZIP function
Â  Â  Â  Â  Â  Â  Â  Â  statusMessage.innerHTML += `<p class="mt-4 text-green-700 font-semibold">Conversion and ZIP download complete! ðŸŽ‰</p>`;
Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  statusMessage.textContent = `Finished processing all files. No CSVs were generated. Please check your timestamp column name.`;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  if (errorCount > 0) {
Â  Â  Â  Â  Â  Â  Â  Â  statusMessage.textContent += ` (Note: ${errorCount} file(s) encountered an error during processing.)`;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  } catch (error) {
Â  Â  Â  Â  Â  Â  console.error("Overall processing error:", error);
Â  Â  Â  Â  Â  Â  statusMessage.textContent = `A critical error occurred during batch processing. Check console for details.`;
Â  Â  Â  Â  }
Â  Â  });

Â  Â  // We no longer need a separate listener for downloadAllButton, as it's triggered above.
Â  Â  // downloadAllButton.addEventListener('click', downloadAllAsZip, false);

Â  Â  /**
Â  Â  Â * Handles the file selection event and stores the files for later processing.
Â  Â  Â * @param {Event} event The file input change event.
Â  Â  Â */
Â  Â  function handleFiles(event) {
Â  Â  Â  Â  uploadedFiles = event.target.files;

Â  Â  Â  Â  if (!uploadedFiles || uploadedFiles.length === 0) {
Â  Â  Â  Â  Â  Â  statusMessage.textContent = 'No files selected.';
Â  Â  Â  Â  Â  Â  columnInputContainer.classList.add('hidden');
Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  }

Â  Â  Â  Â  statusMessage.textContent = `${uploadedFiles.length} file(s) selected. Please enter the column name to split by, then click 'Split and Convert All'.`;
Â  Â  Â  Â  columnInputContainer.classList.remove('hidden');
Â  Â  Â  Â  downloadContainer.classList.add('hidden');
Â  Â  Â  Â  downloadLinks.innerHTML = '';
Â  Â  }

Â  Â  /**
Â  Â  Â * Processes an individual file, splits it by time, and ADDS the CSV data to the allCSVs array.
Â  Â  Â * @param {File} file The file object to process.
Â  Â  Â * @returns {Promise<void>}
Â  Â  Â */
Â  Â  function processFile(file) {
Â  Â  Â  Â  return new Promise((resolve, reject) => {
Â  Â  Â  Â  Â  Â  const timeColumnName = timeColumnNameInput.value.trim();
Â  Â  Â  Â  Â  Â  if (!timeColumnName) {
Â  Â  Â  Â  Â  Â  Â  Â  return reject(new Error('Missing column name.'));
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  const reader = new FileReader();

Â  Â  Â  Â  Â  Â  reader.onload = function(e) {
Â  Â  Â  Â  Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const data = new Uint8Array(e.target.result);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const workbook = XLSX.read(data, { type: 'array' });
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const sheetName = workbook.SheetNames[0];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const worksheet = workbook.Sheets[sheetName];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Get the value of cell D2 for filename prefix
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const d2Cell = worksheet['D2'];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const filePrefix = (d2Cell && d2Cell.v ? String(d2Cell.v).substring(0, 3) : 'DEF').toUpperCase();

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Convert the sheet to an array of JSON objects
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const jsonData = XLSX.utils.sheet_to_json(worksheet);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (jsonData.length === 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return resolve(); // Resolve if empty, just no data to split
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Find the F column header, robustly
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const fKey = Object.keys(jsonData[0] || {}).find(key => String(key).trim().toUpperCase() === 'F');

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Group rows by the specified time column's exact value
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const groupedData = {};
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  jsonData.forEach(row => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const timeValue = row[timeColumnName];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const key = timeValue ? String(timeValue).trim() : 'undated-records';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (!groupedData[key]) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  groupedData[key] = [];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  groupedData[key].push(row);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  });

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const uniqueTimeKeys = Object.keys(groupedData);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (uniqueTimeKeys.length === 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return resolve();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  uniqueTimeKeys.forEach(timeKey => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const group = groupedData[timeKey];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const groupWorksheet = XLSX.utils.json_to_sheet(group);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const csvData = XLSX.utils.sheet_to_csv(groupWorksheet);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const originalFileNameWithoutExtension = file.name.split('.').slice(0, -1).join('.');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Use the value from the specified F column, or a fallback
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const fColumnValue = fKey && group[0][fKey] ? String(group[0][fKey]).trim() : '';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const safeFColumnValue = fColumnValue.replace(/[\\/:*?"<>|]/g, '');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const rowCount = group.length;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Create the final file name
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const timePart = timeKey === 'undated-records' ? 'UNDATED' : timeKey.replace(/[\\/:*?"<>|]/g, '_');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const fileName = `${rowCount}_ROWS_${originalFileNameWithoutExtension}_${timePart}_${safeFColumnValue}.csv`.trim();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Add to the global array for ZIP download
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  allCSVs.push({ filename: fileName, data: csvData });
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  });

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  resolve();

Â  Â  Â  Â  Â  Â  Â  Â  } catch (error) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  reject(error); // Pass the error up the chain
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  };

Â  Â  Â  Â  Â  Â  reader.onerror = function() {
Â  Â  Â  Â  Â  Â  Â  Â  reject(new Error(`Error reading file: ${file.name}`));
Â  Â  Â  Â  Â  Â  };

Â  Â  Â  Â  Â  Â  reader.readAsArrayBuffer(file);
Â  Â  Â  Â  });
Â  Â  }

Â  Â  /**
Â  Â  Â * Downloads all generated CSVs as a single ZIP file.
Â  Â  Â * This is now an async function to be awaited after all files are processed.
Â  Â  Â */
Â  Â  async function downloadAllAsZip() {
Â  Â  Â  Â  if (allCSVs.length === 0) {
Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  }

Â  Â  Â  Â  const zip = new JSZip();
Â  Â  Â  Â Â 
Â  Â  Â  Â  // Use a Set to ensure unique filenames in the ZIP
Â  Â  Â  Â  const filenameSet = new Set();
Â  Â  Â  Â  allCSVs.forEach(file => {
Â  Â  Â  Â  Â  Â  let safeFilename = file.filename;
Â  Â  Â  Â  Â  Â  let counter = 1;
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  // Deduplication logic for files with the exact same name (unlikely but safe)
Â  Â  Â  Â  Â  Â  while (filenameSet.has(safeFilename)) {
Â  Â  Â  Â  Â  Â  Â  Â  const parts = file.filename.split('.');
Â  Â  Â  Â  Â  Â  Â  Â  const extension = parts.pop();
Â  Â  Â  Â  Â  Â  Â  Â  const base = parts.join('.');
Â  Â  Â  Â  Â  Â  Â  Â  safeFilename = `${base} (${counter++}).${extension}`;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  filenameSet.add(safeFilename);
Â  Â  Â  Â  Â  Â  zip.file(safeFilename, file.data);
Â  Â  Â  Â  });

Â  Â  Â  Â  const content = await zip.generateAsync({ type: "blob" });
Â  Â  Â  Â  // --- THIS LINE IS CHANGED ---
Â  Â  Â  Â  const zipFileName = "CSVs.zip";
Â  Â  Â  Â  // ---------------------------
Â  Â  Â  Â  triggerDownload(URL.createObjectURL(content), zipFileName);
Â  Â  }
</script>

</body>
</html>
