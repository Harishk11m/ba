<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XLSX to CSV Converter</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen flex items-center justify-center p-4">

    <div class="bg-white p-8 rounded-2xl shadow-xl max-w-xl w-full text-center">

        <h1 class="text-3xl font-bold text-gray-800 mb-2">XLSX to CSV Converter</h1>
        <p class="text-gray-600 mb-6">Select one or more Excel (.xlsx) files to convert them to Comma-Separated Values (.csv) files, split by the exact timestamp.</p>

        <input type="file" id="fileInput" accept=".xlsx" class="hidden" multiple />
        
        <button onclick="document.getElementById('fileInput').click()"
            class="w-full bg-blue-600 hover:bg-blue-700 text-white font-semibold py-3 px-6 rounded-xl transition duration-300 ease-in-out shadow-lg transform hover:scale-105 mb-6">
            Choose Excel Files
        </button>

        <div id="columnInputContainer" class="hidden mb-4">
            <label for="timeColumnName" class="block text-gray-700 font-medium mb-2 text-left">Enter the name of the timestamp column:</label>
            <input type="text" id="timeColumnName" placeholder="IST TIME" value="IST TIME"
                   class="w-full px-4 py-2 border border-gray-300 rounded-xl focus:outline-none focus:ring-2 focus:ring-blue-500" />
            <button id="splitButton"
                    class="mt-4 w-full bg-blue-600 hover:bg-blue-700 text-white font-semibold py-3 px-6 rounded-xl transition duration-300 ease-in-out">
                Split and Convert All
            </button>
        </div>

        <div id="statusMessage" class="text-gray-700 font-medium mb-4"></div>

        <div id="downloadContainer" class="hidden">
            <h2 class="text-xl font-bold text-gray-800 mb-4">Download your files:</h2>
            <div id="downloadLinks" class="space-y-3">
            </div>
            <button id="downloadAllButton"
                    class="mt-6 w-full bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-3 px-6 rounded-xl transition duration-300 ease-in-out shadow-lg transform hover:scale-105">
                Download All as ZIP
            </button>
        </div>
    </div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.7.1/jszip.min.js"></script>

<script>
    // Get references to DOM elements
    const fileInput = document.getElementById('fileInput');
    const statusMessage = document.getElementById('statusMessage');
    const columnInputContainer = document.getElementById('columnInputContainer');
    const timeColumnNameInput = document.getElementById('timeColumnName');
    const splitButton = document.getElementById('splitButton');
    const downloadContainer = document.getElementById('downloadContainer');
    const downloadLinks = document.getElementById('downloadLinks'); 
    const downloadAllButton = document.getElementById('downloadAllButton');

    let uploadedFiles = null;
    let allCSVs = []; // Array to hold all CSV data and filenames

    // --- Helper Function to Trigger Download ---
    function triggerDownload(url, filename) {
        const link = document.createElement('a');
        link.href = url;
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    }
    
    // Listen for a file to be selected
    fileInput.addEventListener('change', handleFiles, false);
    
    // Listen for the split button to be clicked - Now triggers the entire batch process and final ZIP download
    splitButton.addEventListener('click', async () => {
        if (!uploadedFiles || uploadedFiles.length === 0) {
            statusMessage.textContent = 'Please select files first.';
            return;
        }
        
        allCSVs = []; // Reset the list of CSVs for a new batch of files
        statusMessage.textContent = `Starting conversion for ${uploadedFiles.length} file(s)... This may take a moment... ⏳`;
        downloadContainer.classList.add('hidden');
        downloadLinks.innerHTML = ''; // Clear previous links

        const filesArray = Array.from(uploadedFiles);
        let errorCount = 0;
        
        try {
            // Process each file sequentially and wait for it to complete
            for (const file of filesArray) {
                try {
                    await processFile(file);
                    statusMessage.textContent = `Finished processing "${file.name}". Starting next file...`;
                } catch (e) {
                    console.error(`Error processing file ${file.name}:`, e);
                    statusMessage.textContent = `Error processing "${file.name}". Skipping file.`;
                    errorCount++;
                }
            }

            // After all files are processed, generate and download the ZIP
            if (allCSVs.length > 0) {
                statusMessage.innerHTML = `All files processed! The following ${allCSVs.length} files will be in the ZIP: <ul class="list-disc list-inside mt-2 text-left">` + allCSVs.map(f => `<li class="text-sm text-gray-600">${f.filename}</li>`).join('') + `</ul>`;
                await downloadAllAsZip(); // Call the ZIP function
                statusMessage.innerHTML += `<p class="mt-4 text-green-700 font-semibold">Conversion and ZIP download complete! 🎉</p>`;
            } else {
                statusMessage.textContent = `Finished processing all files. No CSVs were generated. Please check your timestamp column name.`;
            }
            
            if (errorCount > 0) {
                statusMessage.textContent += ` (Note: ${errorCount} file(s) encountered an error during processing.)`;
            }

        } catch (error) {
            console.error("Overall processing error:", error);
            statusMessage.textContent = `A critical error occurred during batch processing. Check console for details.`;
        }
    });

    // We no longer need a separate listener for downloadAllButton, as it's triggered above.
    // downloadAllButton.addEventListener('click', downloadAllAsZip, false);

    /**
     * Handles the file selection event and stores the files for later processing.
     * @param {Event} event The file input change event.
     */
    function handleFiles(event) {
        uploadedFiles = event.target.files;

        if (!uploadedFiles || uploadedFiles.length === 0) {
            statusMessage.textContent = 'No files selected.';
            columnInputContainer.classList.add('hidden');
            return;
        }

        statusMessage.textContent = `${uploadedFiles.length} file(s) selected. Please enter the column name to split by, then click 'Split and Convert All'.`;
        columnInputContainer.classList.remove('hidden');
        downloadContainer.classList.add('hidden');
        downloadLinks.innerHTML = '';
    }

    /**
     * Processes an individual file, splits it by time, and ADDS the CSV data to the allCSVs array.
     * @param {File} file The file object to process.
     * @returns {Promise<void>}
     */
    function processFile(file) {
        return new Promise((resolve, reject) => {
            const timeColumnName = timeColumnNameInput.value.trim();
            if (!timeColumnName) {
                return reject(new Error('Missing column name.'));
            }

            const reader = new FileReader();

            reader.onload = function(e) {
                try {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, { type: 'array' });
                    const sheetName = workbook.SheetNames[0];
                    const worksheet = workbook.Sheets[sheetName];
                    
                    // Get the value of cell D2 for filename prefix
                    const d2Cell = worksheet['D2'];
                    const filePrefix = (d2Cell && d2Cell.v ? String(d2Cell.v).substring(0, 3) : 'DEF').toUpperCase();

                    // Convert the sheet to an array of JSON objects
                    const jsonData = XLSX.utils.sheet_to_json(worksheet);

                    if (jsonData.length === 0) {
                        return resolve(); // Resolve if empty, just no data to split
                    }

                    // Find the F column header, robustly
                    const fKey = Object.keys(jsonData[0] || {}).find(key => String(key).trim().toUpperCase() === 'F');

                    // Group rows by the specified time column's exact value
                    const groupedData = {};
                    jsonData.forEach(row => {
                        const timeValue = row[timeColumnName];
                        const key = timeValue ? String(timeValue).trim() : 'undated-records';
                        
                        if (!groupedData[key]) {
                            groupedData[key] = [];
                        }
                        groupedData[key].push(row);
                    });

                    const uniqueTimeKeys = Object.keys(groupedData);
                    if (uniqueTimeKeys.length === 0) {
                        return resolve();
                    }

                    uniqueTimeKeys.forEach(timeKey => {
                        const group = groupedData[timeKey];
                        const groupWorksheet = XLSX.utils.json_to_sheet(group);
                        const csvData = XLSX.utils.sheet_to_csv(groupWorksheet);
                        
                        const originalFileNameWithoutExtension = file.name.split('.').slice(0, -1).join('.');
                        
                        // Use the value from the specified F column, or a fallback
                        const fColumnValue = fKey && group[0][fKey] ? String(group[0][fKey]).trim() : '';
                        const safeFColumnValue = fColumnValue.replace(/[\\/:*?"<>|]/g, '');
                        const rowCount = group.length;

                        // Create the final file name
                        const timePart = timeKey === 'undated-records' ? 'UNDATED' : timeKey.replace(/[\\/:*?"<>|]/g, '_');
                        const fileName = `${rowCount}_ROWS_${originalFileNameWithoutExtension}_${timePart}_${safeFColumnValue}.csv`.trim();
                        
                        // Add to the global array for ZIP download
                        allCSVs.push({ filename: fileName, data: csvData });
                    });

                    resolve();

                } catch (error) {
                    reject(error); // Pass the error up the chain
                }
            };

            reader.onerror = function() {
                reject(new Error(`Error reading file: ${file.name}`));
            };

            reader.readAsArrayBuffer(file);
        });
    }

    /**
     * Downloads all generated CSVs as a single ZIP file.
     * This is now an async function to be awaited after all files are processed.
     */
    async function downloadAllAsZip() {
        if (allCSVs.length === 0) {
            return;
        }

        const zip = new JSZip();
        
        // Use a Set to ensure unique filenames in the ZIP
        const filenameSet = new Set();
        allCSVs.forEach(file => {
            let safeFilename = file.filename;
            let counter = 1;
            
            // Deduplication logic for files with the exact same name (unlikely but safe)
            while (filenameSet.has(safeFilename)) {
                const parts = file.filename.split('.');
                const extension = parts.pop();
                const base = parts.join('.');
                safeFilename = `${base} (${counter++}).${extension}`;
            }
            
            filenameSet.add(safeFilename);
            zip.file(safeFilename, file.data);
        });

        const content = await zip.generateAsync({ type: "blob" });
        // --- THIS LINE IS CHANGED ---
        const zipFileName = "CSVs.zip";
        // ---------------------------
        triggerDownload(URL.createObjectURL(content), zipFileName);
    }
</script>

</body>
</html>
